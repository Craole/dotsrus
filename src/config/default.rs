use directories::{BaseDirs, ProjectDirs};
use ignore::WalkBuilder;
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    error::Error,
    fs::{self, File},
    io::{self, Write},
    path::{Path, PathBuf},
};

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct Config {
    pub path_entries: Vec<PathEntry>,
    pub config_path: PathBuf,
    #[serde(default = "default_excludes")]
    pub default_excludes: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PathEntry {
    pub path: PathBuf,
    pub prepend: bool,
    pub exclude_patterns: Vec<String>,
    pub max_depth: u8,
    #[serde(default)]
    pub discovered_paths: HashMap<PathBuf, LastCheck>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LastCheck {
    pub timestamp: std::time::SystemTime,
    pub valid: bool,
}

fn default_excludes() -> Vec<String> {
    vec![
        "temp".to_string(),
        "tmp".to_string(),
        "review".to_string(),
        "archive".to_string(),
        "backup".to_string(),
        "node_modules".to_string(),
        "target".to_string(),
        ".git".to_string(),
    ]
}

impl Config {
    pub fn new(custom_config_path: Option<&Path>) -> io::Result<Self> {
        let config_path = if let Some(path) = custom_config_path {
            path.to_path_buf()
        } else {
            let proj_dirs = ProjectDirs::from("com", "dots", "dots")
                .expect("Failed to determine config directory");
            proj_dirs.config_dir().join("config.toml")
        };

        if !config_path.exists() {
            if let Some(parent) = config_path.parent() {
                fs::create_dir_all(parent)?;
            }
            File::create(&config_path)?;
            Ok(Config {
                path_entries: Vec::new(),
                config_path,
                default_excludes: default_excludes(),
            })
        } else {
            let content = fs::read_to_string(&config_path)?;
            let mut config: Config = toml::from_str(&content).unwrap_or_default();
            config.config_path = config_path;
            Ok(config)
        }
    }

    pub fn save(&self) -> Result<(), Box<dyn Error>> {
        let content = toml::to_string_pretty(self)?;
        fs::write(&self.config_path, content)?;
        self.update_shell_profile()?;
        Ok(())
    }

    fn update_shell_profile(&self) -> Result<(), Box<dyn Error>> {
        let base_dir = BaseDirs::new().expect("Failed to get base directories");
        let home_dir = base_dir.home_dir().to_path_buf();
        let profile_paths = vec![
            home_dir.join(".profile"),
            home_dir.join(".bashrc"),
            home_dir.join(".zshrc"),
        ];

        let source_line = format!(
            "\n#| dotDots\n. {}\n",
            self.config_path.with_extension("sh").display()
        );

        for profile_path in profile_paths {
            if profile_path.exists() {
                let content = fs::read_to_string(&profile_path)?;
                if !content.contains("#| dotDots") {
                    let mut file = fs::OpenOptions::new().append(true).open(profile_path)?;
                    writeln!(file, "{}", source_line)?;
                }
            }
        }

        //@ Generate shell script
        let mut shell_script = String::new();
        shell_script.push_str("#!/bin/sh\n\n");
        shell_script.push_str("# Generated by dots\n");

        //@ Export current PATH first to preserve existing entries
        shell_script.push_str("export PATH=\"$PATH");

        //@ Add custom paths
        for entry in &self.path_entries {
            //@ Add the main path
            shell_script.push_str(&format!(":{}", entry.path.display()));

            //@ Add discovered paths
            for discovered in entry.discovered_paths.keys() {
                if *discovered != entry.path {
                    shell_script.push_str(&format!(":{}", discovered.display()));
                }
            }
        }
        shell_script.push_str("\"\n");

        fs::write(self.config_path.with_extension("sh"), shell_script)?;

        Ok(())
    }

    pub fn should_exclude(&self, path: &Path, entry_excludes: &[String]) -> bool {
        let path_str = path.to_string_lossy().to_lowercase();

        //@ Check default excludes
        if self.default_excludes.iter().any(|e| path_str.contains(e)) {
            return true;
        }

        //@ Check custom excludes
        if entry_excludes.iter().any(|e| path_str.contains(e)) {
            return true;
        }

        //@ Check if path is ignored by .gitignore or .ignore
        if let Some(parent) = path.parent() {
            let walker = WalkBuilder::new(parent)
                .hidden(true)
                .git_ignore(true)
                .ignore(true)
                .build();

            for entry in walker.flatten() {
                if entry.path() == path {
                    return entry.path().starts_with(".git") || entry.depth() == 0;
                    // Consider only root level for ignore status
                }
            }
        }

        false
    }
}
